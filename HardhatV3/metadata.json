{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c0dd8a2160c030d882ae4dbdddfb69c9667881ff",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PayrollManager.sol": "project/contracts/PayrollManager.sol",
    "contracts/PayrollManagerERC20Only/PayrollManagerOld.sol": "project/contracts/PayrollManagerERC20Only/PayrollManagerOld.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:forge-std/interfaces/IERC20.sol=npm/forge-std@1.9.4/src/interfaces/IERC20.sol",
        "project/:forge-std/interfaces/IERC20.sol=npm/forge-std@1.9.4/src/interfaces/IERC20.sol"
      ]
    },
    "sources": {
      "npm/forge-std@1.9.4/src/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"
      },
      "project/contracts/PayrollManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\n\n/// @title PayrollManager (Supports ERC20 & Native Tokens)\n/// @notice Handles payroll scheduling and execution with optional native token support\ncontract PayrollManager {\n    /*//////////////////////////////////////////////////////////////\n                               STATE\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable owner;\n    bool public paused;\n\n    struct Payment {\n        address payer;\n        address recipient;\n        address token; // address(0) = native token\n        uint256 amount;\n        uint256 chainId;\n        bool executed;\n    }\n\n    Payment[] public payments;\n    uint256 public totalEscrowed;\n\n    mapping(address => bool) public isAdmin;\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PaymentScheduled(\n        address indexed payer,\n        address indexed recipient,\n        uint256 amount,\n        address indexed token,\n        uint256 chainId\n    );\n    event PaymentExecuted(uint256 indexed id, address indexed recipient, uint256 amount, address token);\n    event FundsMovedToYield(address indexed token, uint256 amount, string note);\n    event FundsRecalledFromYield(address indexed token, uint256 amount, string note);\n    event Paused(address indexed by);\n    event Unpaused(address indexed by);\n    event AdminUpdated(address indexed admin, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                              MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender], \"Not admin\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"Paused\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        owner = msg.sender;\n        isAdmin[msg.sender] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           ADMIN & PAUSE CONTROL\n    //////////////////////////////////////////////////////////////*/\n\n    function addAdmin(address _admin) external onlyOwner {\n        require(_admin != address(0), \"Zero address\");\n        isAdmin[_admin] = true;\n        emit AdminUpdated(_admin, true);\n    }\n\n    function removeAdmin(address _admin) external onlyOwner {\n        require(isAdmin[_admin], \"Not admin\");\n        isAdmin[_admin] = false;\n        emit AdminUpdated(_admin, false);\n    }\n\n    function pause() external onlyAdmin {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external onlyAdmin {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Schedule a payment (supports ERC20 or native token)\n    /// @dev If _token == address(0), caller must send ETH/HBAR/Native equal to _amount\n    function schedulePayment(\n        address _recipient,\n        address _token,\n        uint256 _amount,\n        uint256 _chainId\n    ) external payable whenNotPaused {\n        require(_recipient != address(0), \"Invalid recipient\");\n        require(_amount > 0, \"Zero amount\");\n\n        if (_token == address(0)) {\n            // Native token: require exact msg.value\n            require(msg.value == _amount, \"Incorrect native token amount\");\n        } else {\n            // ERC20 token payment: transfer tokens into contract\n            IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n        }\n\n        payments.push(\n            Payment({\n                payer: msg.sender,\n                recipient: _recipient,\n                token: _token,\n                amount: _amount,\n                chainId: _chainId,\n                executed: false\n            })\n        );\n\n        unchecked {\n            totalEscrowed += _amount;\n        }\n\n        emit PaymentScheduled(msg.sender, _recipient, _amount, _token, _chainId);\n    }\n\n    /// @notice Execute a scheduled payment (anyone can trigger)\n    function executePayment(uint256 _id) external whenNotPaused {\n        require(_id < payments.length, \"Invalid ID\");\n\n        Payment storage p = payments[_id];\n        require(!p.executed, \"Already executed\");\n\n        p.executed = true;\n\n        unchecked {\n            totalEscrowed -= p.amount;\n        }\n\n        if (p.token == address(0)) {\n            // send native token\n            (bool success, ) = p.recipient.call{value: p.amount}(\"\");\n            require(success, \"Native token transfer failed\");\n        } else {\n            // send ERC20\n            IERC20(p.token).transfer(p.recipient, p.amount);\n        }\n\n        emit PaymentExecuted(_id, p.recipient, p.amount, p.token);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          MANUAL YIELD MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Admin manually moves idle funds to a yield provider wallet (off-chain)\n    function moveFundsToYield(\n        address _token,\n        address _yieldWallet,\n        uint256 _amount,\n        string calldata _note\n    ) external onlyAdmin whenNotPaused {\n        require(_yieldWallet != address(0), \"Invalid wallet\");\n        require(_amount > 0, \"Zero amount\");\n\n        if (_token == address(0)) {\n            require(address(this).balance >= _amount, \"Insufficient native balance\");\n            (bool success, ) = _yieldWallet.call{value: _amount}(\"\");\n            require(success, \"Native transfer failed\");\n        } else {\n            IERC20 token = IERC20(_token);\n            uint256 bal = token.balanceOf(address(this));\n            require(bal >= _amount, \"Insufficient ERC20 balance\");\n            token.transfer(_yieldWallet, _amount);\n        }\n\n        emit FundsMovedToYield(_token, _amount, _note);\n    }\n\n    /// @notice Admin recalls yield funds back into contract\n    /// @dev For native token recall, admin should send native value equal to _amount\n    function recallFundsFromYield(\n        address _token,\n        uint256 _amount,\n        string calldata _note\n    ) external payable onlyAdmin whenNotPaused {\n        require(_amount > 0, \"Zero amount\");\n\n        if (_token == address(0)) {\n            // admin transfers native back via msg.value\n            require(msg.value == _amount, \"Incorrect native deposit\");\n        } else {\n            IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n        }\n\n        emit FundsRecalledFromYield(_token, _amount, _note);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              OWNER CONTROL\n    //////////////////////////////////////////////////////////////*/\n\n    function emergencyWithdraw(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        require(_to != address(0), \"Invalid address\");\n\n        if (_token == address(0)) {\n            (bool success, ) = _to.call{value: _amount}(\"\");\n            require(success, \"Native withdraw failed\");\n        } else {\n            IERC20(_token).transfer(_to, _amount);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    function getPaymentsCount() external view returns (uint256) {\n        return payments.length;\n    }\n\n    function getBalance(address _token) external view returns (uint256) {\n        if (_token == address(0)) {\n            return address(this).balance;\n        } else {\n            return IERC20(_token).balanceOf(address(this));\n        }\n    }\n\n    // Accept plain native transfers\n    receive() external payable {}\n}\n"
      },
      "project/contracts/PayrollManagerERC20Only/PayrollManagerOld.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\n\n/// @title PayrollManager (Manual Yield-Managed Escrow)\n/// @notice Handles payroll scheduling and execution with manual admin yield management\ncontract PayrollManagerOld {\n    /*//////////////////////////////////////////////////////////////\n                               STATE\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable owner;\n    bool public paused;\n\n    struct Payment {\n        address payer;\n        address recipient;\n        address token;\n        uint256 amount;\n        uint256 chainId;\n        bool executed;\n    }\n\n    Payment[] public payments;\n    uint256 public totalEscrowed;\n\n    mapping(address => bool) public isAdmin;\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PaymentScheduled(address indexed payer, address indexed recipient, uint256 amount, address indexed token, uint256 chainId);\n    event PaymentExecuted(uint256 indexed id, address indexed recipient, uint256 amount);\n    event FundsMovedToYield(address indexed token, uint256 amount, string note);\n    event FundsRecalledFromYield(address indexed token, uint256 amount, string note);\n    event Paused(address indexed by);\n    event Unpaused(address indexed by);\n    event AdminUpdated(address indexed admin, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                              MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender], \"Not admin\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"Paused\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        owner = msg.sender;\n        isAdmin[msg.sender] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           ADMIN & PAUSE CONTROL\n    //////////////////////////////////////////////////////////////*/\n\n    function addAdmin(address _admin) external onlyOwner {\n        require(_admin != address(0), \"Zero address\");\n        isAdmin[_admin] = true;\n        emit AdminUpdated(_admin, true);\n    }\n\n    function removeAdmin(address _admin) external onlyOwner {\n        require(isAdmin[_admin], \"Not admin\");\n        isAdmin[_admin] = false;\n        emit AdminUpdated(_admin, false);\n    }\n\n    function pause() external onlyAdmin {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external onlyAdmin {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Schedule a payment (anyone can schedule when not paused)\n    function schedulePayment(\n        address _recipient,\n        address _token,\n        uint256 _amount,\n        uint256 _chainId\n    ) external whenNotPaused {\n        require(_recipient != address(0), \"Invalid recipient\");\n        require(_amount > 0, \"Zero amount\");\n\n        // Transfer funds from payer to contract\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n\n        payments.push(Payment({\n            payer: msg.sender,\n            recipient: _recipient,\n            token: _token,\n            amount: _amount,\n            chainId: _chainId,\n            executed: false\n        }));\n\n        unchecked {\n            totalEscrowed += _amount;\n        }\n\n        emit PaymentScheduled(msg.sender, _recipient, _amount, _token, _chainId);\n    }\n\n    /// @notice Execute a scheduled payment (anyone can trigger)\n    function executePayment(uint256 _id) external whenNotPaused {\n        require(_id < payments.length, \"Invalid ID\");\n        Payment storage p = payments[_id];\n        require(!p.executed, \"Already executed\");\n\n        p.executed = true;\n\n        unchecked {\n            totalEscrowed -= p.amount;\n        }\n\n        IERC20(p.token).transfer(p.recipient, p.amount);\n        emit PaymentExecuted(_id, p.recipient, p.amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          MANUAL YIELD MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Admin manually moves idle funds to a yield provider wallet (off-chain)\n    function moveFundsToYield(\n        address _token,\n        address _yieldWallet,\n        uint256 _amount,\n        string calldata _note\n    ) external onlyAdmin {\n        require(!paused, \"Paused\");\n        require(_yieldWallet != address(0), \"Invalid wallet\");\n        require(_amount > 0, \"Zero amount\");\n\n        IERC20 token = IERC20(_token);\n        uint256 bal = token.balanceOf(address(this));\n        require(bal >= _amount, \"Insufficient balance\");\n\n        token.transfer(_yieldWallet, _amount);\n        emit FundsMovedToYield(_token, _amount, _note);\n    }\n\n    /// @notice Admin recalls yield funds back into contract\n    function recallFundsFromYield(\n        address _token,\n        uint256 _amount,\n        string calldata _note\n    ) external onlyAdmin {\n        require(!paused, \"Paused\");\n        require(_amount > 0, \"Zero amount\");\n\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n        emit FundsRecalledFromYield(_token, _amount, _note);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              OWNER CONTROL\n    //////////////////////////////////////////////////////////////*/\n\n    function emergencyWithdraw(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        require(_to != address(0), \"Invalid address\");\n        IERC20(_token).transfer(_to, _amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    function getPaymentsCount() external view returns (uint256) {\n        return payments.length;\n    }\n\n    function getBalance(address _token) external view returns (uint256) {\n        return IERC20(_token).balanceOf(address(this));\n    }\n}\n"
      }
    }
  }
}